-- ============ Auto Walk Recorder V4 ‚Äì Rayfield (Multi Save + Precise Stop) ============
-- Fitur:
-- 1) Record ‚ûú Red (start) + data frame + Yellow (end) [snap to ground]
-- 2) Auto-Save per Stop Record -> Save 1, Save 2, ...
-- 3) Play per-save (pathfind ke RED, replay halus BodyVelocity, STOP tepat di YELLOW)
-- 4) Delete per-save (destroy parts + hapus dari UI)
-- 5) Save All -> autowalk_all.json
-- 6) Tab terpisah: Record vs Save/Load, tema biru Rayfield.

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

-- Rayfield UI
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local Window = Rayfield:CreateWindow({
	Name = "Auto Walk Recorder V4",
	LoadingTitle = "Init Recorder",
	LoadingSubtitle = "Record ‚Ä¢ Replay ‚Ä¢ Multi-Save",
	KeySystem = false
})
local TabRecord = Window:CreateTab("üé• Record", 4483362458)
local TabSave   = Window:CreateTab("üíæ Save",   4483362458)
local TabOpts   = Window:CreateTab("‚öôÔ∏è Options",4483362458)

-- ===== State =====
local recording = false
local playSpeed = 1
local BV -- BodyVelocity
local startTime
local jumpConn

-- Struktur Save:
-- saves[id] = {
--   id = 1,
--   name = "Save 1",
--   red = <Part>,
--   yellow = <Part>,
--   frames = { {t, pos={x,y,z}, isJump}, ... },
--   ui = { playBtn=..., delBtn=..., sep=... }
-- }
local saves = {}
local nextSaveId = 1

local function notify(msg) Rayfield:Notify({Title="Auto Walk", Content=msg, Duration=3}) end

-- ===== Helpers =====
local function ensureBV()
	if not BV or not BV.Parent then
		BV = Instance.new("BodyVelocity")
		BV.MaxForce = Vector3.new(1e5, 0, 1e5)
		BV.P = 1e4
		BV.Velocity = Vector3.zero
		BV.Parent = hrp
	end
end

local function cleanupBV()
	if BV then
		pcall(function() BV.Velocity = Vector3.zero end)
		pcall(function() BV:Destroy() end)
		BV = nil
	end
	pcall(function() hrp.AssemblyLinearVelocity = Vector3.zero end)
end

local function groundSnap(pos)
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {character}
	params.FilterType = Enum.RaycastFilterType.Blacklist
	local res = workspace:Raycast(pos + Vector3.new(0,5,0), Vector3.new(0,-500,0), params)
	if res then
		return Vector3.new(pos.X, res.Position.Y + 0.5, pos.Z)
	else
		return pos - Vector3.new(0,3,0)
	end
end

local function pathfindWalk(targetPos)
	local path = PathfindingService:CreatePath()
	path:ComputeAsync(hrp.Position, targetPos)
	if path.Status == Enum.PathStatus.Success then
		for _, wp in ipairs(path:GetWaypoints()) do
			humanoid:MoveTo(wp.Position)
			if wp.Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end
			humanoid.MoveToFinished:Wait()
		end
	else
		humanoid:MoveTo(targetPos)
		humanoid.MoveToFinished:Wait()
	end
end

-- ===== UI Save List =====
local SaveListSection = TabSave:CreateSection("Saves")
local saveListContainer = {}  -- hanya marker; Rayfield tidak punya container, kita simpan refs di saves[id].ui

local function removeSaveUI(id)
	local s = saves[id]
	if not s or not s.ui then return end
	for key, inst in pairs(s.ui) do
		if typeof(inst) == "table" and inst.Destroy then
			-- in case
		end
	end
	-- Rayfield tidak expose Destroy, tapi kita bisa hide dg mengganti labelnya.
	-- Solusi: kita buat ulang UI saat delete (rebuild).
end

local function rebuildSaveUI()
	-- Hapus semua entri UI lalu buat ulang (Rayfield tidak support destroy per-button).
	TabSave:CreateSection("Saves (refreshed)")
	-- Untuk mencegah UI memanjang terus, cukup informatif.
	for _, s in ipairs(saves) do
		if s then
			TabSave:CreateDivider(s.name)
			TabSave:CreateButton({
				Name = "‚ñ∂ Play "..s.name,
				Callback = function()
					-- Play per-save
					task.spawn(function()
						-- 1) jalan ke RED start
						pathfindWalk(s.red.Position + Vector3.new(0,3,0))

						-- 2) replay frames halus sesuai timing
						if s.frames and #s.frames > 1 then
							ensureBV()
							for i=1, #s.frames-1 do
								local a, b = s.frames[i], s.frames[i+1]
								local pA = Vector3.new(a.pos[1], a.pos[2], a.pos[3])
								local pB = Vector3.new(b.pos[1], b.pos[2], b.pos[3])
								local dt = math.max((b.t - a.t)/playSpeed, 1/120)
								local delta = pB - pA
								local flat = Vector3.new(delta.X, 0, delta.Z)
								local dist = flat.Magnitude
								local speed = (dist > 0 and dt > 0) and (dist/dt) or 0

								local t0 = tick()
								while tick()-t0 < dt do
									local remain = dt - (tick()-t0)
									if flat.Magnitude > 1e-3 then
										local decelFactor = math.clamp(remain/dt, 0.1, 1) -- kurangi di akhir
										local v = flat.Unit * speed * decelFactor
										BV.Velocity = Vector3.new(v.X, 0, v.Z)
										hrp.CFrame = CFrame.lookAt(hrp.Position, hrp.Position + flat)
									else
										BV.Velocity = Vector3.zero
									end
									if b.isJump then humanoid.Jump = true end
									RunService.Heartbeat:Wait()
								end
							end
							BV.Velocity = Vector3.zero
						end

						-- 3) pastikan STOP tepat di YELLOW (snap final)
						humanoid:MoveTo(s.yellow.Position + Vector3.new(0,3,0))
						humanoid.MoveToFinished:Wait()
						cleanupBV()
						notify(s.name.." finished.")
					end)
				end
			})
			TabSave:CreateButton({
				Name = "üóë Delete "..s.name,
				Callback = function()
					-- Destroy parts
					if s.red and s.red.Parent then s.red:Destroy() end
					if s.yellow and s.yellow.Parent then s.yellow:Destroy() end
					-- Remove from saves table
					for idx, itm in ipairs(saves) do
						if itm and itm.id == s.id then
							table.remove(saves, idx)
							break
						end
					end
					notify(s.name.." deleted.")
					-- Rebuild UI list
					rebuildSaveUI()
				end
			})
		end
	end
end

-- ===== Record / Stop =====
local function startRecord()
	if recording then return end
	recording = true

	-- buat RED di ground
	local red = Instance.new("Part")
	red.Size = Vector3.new(5,1,5)
	red.Anchored = true
	red.CanCollide = false
	red.Color = Color3.fromRGB(255,0,0)
	red.Position = groundSnap(hrp.Position)
	red.Parent = workspace

	-- frames
	local frames = {}
	startTime = tick()

	-- frame pertama
	table.insert(frames, {t=0, pos={hrp.Position.X, hrp.Position.Y, hrp.Position.Z}, isJump=false})

	-- jump langsung dari input
	if jumpConn then jumpConn:Disconnect() end
	jumpConn = UserInputService.JumpRequest:Connect(function()
		if recording then
			table.insert(frames, { t = tick()-startTime, pos = {hrp.Position.X,hrp.Position.Y,hrp.Position.Z}, isJump = true })
		end
	end)

	-- loop rekam position tiap Heartbeat (halus)
	task.spawn(function()
		while recording do
			table.insert(frames, { t = tick()-startTime, pos = {hrp.Position.X,hrp.Position.Y,hrp.Position.Z}, isJump=false })
			RunService.Heartbeat:Wait()
		end
	end)

	notify("Recording started")
	-- simpan sementara red & frames sebagai upvalue di closure
	_G.__currentRed = red
	_G.__currentFrames = frames
end

local function stopRecord()
	if not recording then return end
	recording = false
	if jumpConn then jumpConn:Disconnect(); jumpConn=nil end

	-- buat YELLOW di ground
	local yellow = Instance.new("Part")
	yellow.Size = Vector3.new(5,1,5)
	yellow.Anchored = true
	yellow.CanCollide = false
	yellow.Color = Color3.fromRGB(255,255,0)
	yellow.Position = groundSnap(hrp.Position)
	yellow.Parent = workspace

	-- Auto-register as new Save
	local id = nextSaveId
	nextSaveId += 1
	local save = {
		id = id,
		name = ("Save %d"):format(id),
		red = _G.__currentRed,
		yellow = yellow,
		frames = _G.__currentFrames
	}
	table.insert(saves, save)
	notify(save.name.." created.")

	-- Refresh daftar Save di TabSave
	rebuildSaveUI()
end

-- ===== Save All =====
local function saveAllToFile()
	if #saves == 0 then
		notify("No saves to write.")
		return
	end
	local out = {}
	for _, s in ipairs(saves) do
		table.insert(out, {
			name = s.name,
			red  = {s.red.Position.X, s.red.Position.Y, s.red.Position.Z},
			yellow = {s.yellow.Position.X, s.yellow.Position.Y, s.yellow.Position.Z},
			frames = s.frames
		})
	end
	local json = HttpService:JSONEncode(out)
	writefile("autowalk_all.json", json)
	notify("Saved all to autowalk_all.json")
end

-- ===== UI (Record Tab) =====
TabRecord:CreateButton({Name="‚ñ∂ Start Record", Callback=startRecord})
TabRecord:CreateButton({Name="‚èπ Stop Record (Auto-Save)", Callback=stopRecord})

TabRecord:CreateSlider({
	Name="Replay Speed",
	Range={0.5,3},
	Increment=0.1,
	Suffix="x",
	CurrentValue=1,
	Callback=function(v) playSpeed=v end
})

TabRecord:CreateSlider({
	Name="WalkSpeed",
	Range={10,200},
	Increment=1,
	Suffix=" ws",
	CurrentValue=humanoid.WalkSpeed,
	Callback=function(v) humanoid.WalkSpeed=v end
})

TabRecord:CreateSlider({
	Name="JumpPower",
	Range={10,300},
	Increment=1,
	Suffix=" jp",
	CurrentValue=humanoid.JumpPower,
	Callback=function(v) humanoid.JumpPower=v end
})

-- ===== UI (Save Tab) =====
TabSave:CreateButton({
	Name = "üíæ Save All (to autowalk_all.json)",
	Callback = saveAllToFile
})

-- Pertama kali kosong, UI list dibangun saat Save dibuat.
rebuildSaveUI()

-- ===== Respawn handling (optional persistence) =====
player.CharacterAdded:Connect(function(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	hrp = char:WaitForChild("HumanoidRootPart")
	cleanupBV()
end)
